<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Comparator接口是如何定义升序降序的</title>
    <url>/2021/05/27/Comparator%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%8D%87%E5%BA%8F%E9%99%8D%E5%BA%8F%E7%9A%84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用Comparator接口时，总是无法很好的理解到什么是升序降序，每次都需要写个用例跑一次才确定。(；′⌒`)</p>
<h1 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h1><h2 id="升序"><a href="#升序" class="headerlink" title="升序"></a>升序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Arrays.sort(arr, (a, b) -&gt; a - b);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<h2 id="降序"><a href="#降序" class="headerlink" title="降序"></a>降序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Arrays.sort(arr, (a, b) -&gt; b - a);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>

<h1 id="浅谈"><a href="#浅谈" class="headerlink" title="浅谈"></a>浅谈</h1><p>在java.util.Comparator#compare方法上的注释，说得很清楚:</p>
<blockquote>
<p>在比较两个参数的顺序时，第一个参数为a， 第二个参数为b</p>
<ol>
<li>a &lt; b时返回负数</li>
<li>a == b时返回0</li>
<li>a &gt; b时返回正数</li>
<li>建议使用-1、0、1来代表三个返回值</li>
</ol>
</blockquote>
<p>在java.util.Arrays#sort(T[], java.util.Comparator&lt;? super T&gt;)实现中，会根据参数使用不同的排序算法，有binary sort和merge sort。这里直接看merge sort的实现，比较容易理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.util.Arrays#mergeSort(java.lang.Object[], java.lang.Object[], int, int, int, java.util.Comparator)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Object[] src,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Object[] dest,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> off,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Comparator c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = high - low;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Insertion sort on smallest arrays</span></span><br><span class="line">        <span class="keyword">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=low; i&lt;high; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;low &amp;&amp; c.compare(dest[j-<span class="number">1</span>], dest[j])&gt;<span class="number">0</span>; j--)</span><br><span class="line">                    swap(dest, j, j-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recursively sort halves of dest into src</span></span><br><span class="line">        <span class="keyword">int</span> destLow  = low;</span><br><span class="line">        <span class="keyword">int</span> destHigh = high;</span><br><span class="line">        low  += off;</span><br><span class="line">        high += off;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        mergeSort(dest, src, low, mid, -off, c);</span><br><span class="line">        mergeSort(dest, src, mid, high, -off, c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If list is already sorted, just copy from src to dest.  This is an</span></span><br><span class="line">        <span class="comment">// optimization that results in faster sorts for nearly ordered lists.</span></span><br><span class="line">        <span class="keyword">if</span> (c.compare(src[mid-<span class="number">1</span>], src[mid]) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           System.arraycopy(src, low, dest, destLow, length);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merge sorted halves (now in src) into dest</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q &gt;= high || p &lt; mid &amp;&amp; c.compare(src[p], src[q]) &lt;= <span class="number">0</span>)</span><br><span class="line">                dest[i] = src[p++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dest[i] = src[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>关键代码位置就是:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=low; i&lt;high; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;low &amp;&amp; c.compare(dest[j-<span class="number">1</span>], dest[j])&gt;<span class="number">0</span>; j--)</span><br><span class="line">            swap(dest, j, j-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里根据的compare方法的返回值来进行了交换。可以看到当返回值大于0时，则交换dest[j-1] 和dest[j]，而返回值小于等于0时，则顺序保持不变。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在Comparator中，只要compare方法的返回值大于0时，就将数组前一个数和后一个数进行交换，也就是说:</p>
<ol>
<li>如果需要升序，那么只要保证在参数a小于参数b时，返回负数即可</li>
<li>如果需要降序，那么只要保证在参数a小于参数b时，返回正数即可</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker镜像部署spring cloud config repo</title>
    <url>/2021/05/21/%E4%BD%BF%E7%94%A8docker%E9%95%9C%E5%83%8F%E9%83%A8%E7%BD%B2spring-cloud-config-repo/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前折腾了一些spring cloud config repo来存放一些项目的配置文件，由于不需要自定义开发，于是就使用了别人制作好的docker镜像。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h2><p>准备好spring cloud confg repo的配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">git@github.com:&#123;username&#125;/&#123;your-config-repo&#125;.git</span></span><br><span class="line">          <span class="attr">timeout:</span> <span class="number">10</span></span><br><span class="line">          <span class="comment"># 添加你的配置文件路径</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">configs</span></span><br><span class="line">          <span class="attr">clone-on-start:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 支持直接使用用户名和密码登录github仓库，但是不推荐</span></span><br><span class="line">          <span class="comment"># github已经警告过将会不再支持该方式</span></span><br><span class="line">          <span class="comment"># 因此这里建议使用ssh来登录到仓库</span></span><br><span class="line">          <span class="comment">#username: </span></span><br><span class="line">          <span class="comment">#password: </span></span><br></pre></td></tr></table></figure>

<h2 id="配置ssh-key"><a href="#配置ssh-key" class="headerlink" title="配置ssh key"></a>配置ssh key</h2><p>如何生成ssh key以及上传到github，详情见<br>(Connecting to GitHub with SSH)[<a href="https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh]">https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh]</a></p>
<h2 id="使用镜像启动"><a href="#使用镜像启动" class="headerlink" title="使用镜像启动"></a>使用镜像启动</h2><p>镜像: <code>hyness/spring-cloud-config-server:2.2.6.RELEASE-jdk8</code></p>
<p>启动命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 需要将application.yml映射到镜像</span></span><br><span class="line"><span class="comment"># 2. 如果是使用ssh来连接到github，那么需要将当前用户的ssh目录映射到镜像</span></span><br><span class="line"><span class="comment"># 3. 如果应用也是跑到docker中，那么建议创建docker net来进行config server与应用的通信</span></span><br><span class="line"><span class="comment">#    否则需要将config server暴露端口给外部应用访问</span></span><br><span class="line"></span><br><span class="line">docker run --name spring-config-server \</span><br><span class="line"> -v ./application.yml:/config/application.yml \</span><br><span class="line"> -v /home/&#123;usr&#125;/.ssh:/root/.ssh \</span><br><span class="line"> -d hyness/spring-cloud-config-server:2.2.6.RELEASE-jdk8</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>关于折腾github pages那些事</title>
    <url>/2021/05/17/%E5%85%B3%E4%BA%8E%E6%8A%98%E8%85%BEgithub-pages%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前用过CSDN来写博客，但由于CSDN越来越拉，不得已就自建博客了。由于之前阿里云到期，现在在折腾腾讯云，自建博客也凉凉。于是就干脆折腾下github pages。</p>
<p>以下是在折腾过程中参考的文章，以及遇到的问题。</p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>以下大部分内容参考的是微信文章<a href="https://mp.weixin.qq.com/s/3li0n8REcU1DviwWiEYw_A">超全面！如何用 GitHub 从零开始搭建一个博客 ？</a>。</p>
<p>这里也不做复制怪了，有兴趣的之前看别人的文章即可。</p>
<p>关于使用github workflow进行自动构建，可以参考官方教程<a href="https://hexo.io/docs/github-pages">GitHub Pages</a>。</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="github-pages的域名问题"><a href="#github-pages的域名问题" class="headerlink" title="github pages的域名问题"></a>github pages的域名问题</h2><p>github pages的域名通常是<code>&#123;username&#125;.github.io</code>，这个前提是基于这个仓库与你的自己账号名相同（不是指登录账号），否则域名将会是<code>&#123;username&#125;.github.io/&#123;reponame&#125;</code>。</p>
<p>同时hexo的模板代码生成的根路径是直接使用的<code>/</code>，所以在有reponame时，访问hexo生成的页面时会加载不到css、js。所以将自己的账号名更改以后，正常的可以用<code>&#123;username&#125;.github.io</code>进行访问。</p>
<h2 id="使用github-workflow构建失败"><a href="#使用github-workflow构建失败" class="headerlink" title="使用github workflow构建失败"></a>使用github workflow构建失败</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The page build failed <span class="keyword">for</span> the `main` branch with the following error:</span><br><span class="line"></span><br><span class="line">The tag `note` on line 11 <span class="keyword">in</span> `themes/next/docs/AUTHORS.md` is not a recognized Liquid tag. For more information, see https://docs.github.com/github/working-with-github-pages/troubleshooting-jekyll-build-errors-for-github-pages-sites<span class="comment">#unknown-tag-error.</span></span><br><span class="line"></span><br><span class="line">For information on troubleshooting Jekyll see:</span><br><span class="line"></span><br><span class="line">  https://docs.github.com/articles/troubleshooting-jekyll-builds</span><br><span class="line"></span><br><span class="line">If you have any questions you can submit a request at https://support.github.com/contact?repo_id=367273128&amp;page_build_id=253761474</span><br></pre></td></tr></table></figure>

<p>在参考了issue<a href="https://github.com/theme-next/hexo-theme-next/issues/410">The tag note is not a recognized Liquid tag</a>，我选择直接删除掉next主题下的doc目录，目前暂不知道是否会有版权问题，如果会造成侵权，那么我再还原回去（逃。</p>
<h2 id="使用github-workflow构建成功却有警告"><a href="#使用github-workflow构建成功却有警告" class="headerlink" title="使用github workflow构建成功却有警告"></a>使用github workflow构建成功却有警告</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The page build completed successfully, but returned the following warning <span class="keyword">for</span> the `main` branch:</span><br><span class="line"></span><br><span class="line">You are attempting to use a Jekyll theme, <span class="string">&quot;next&quot;</span>, <span class="built_in">which</span> is not supported by GitHub Pages. Please visit https://pages.github.com/themes/ <span class="keyword">for</span> a list of supported themes. If you are using the <span class="string">&quot;theme&quot;</span> configuration variable <span class="keyword">for</span> something other than a Jekyll theme, we recommend you rename this variable throughout your site. For more information, see https://docs.github.com/github/working-with-github-pages/adding-a-theme-to-your-github-pages-site-using-jekyll.</span><br><span class="line"></span><br><span class="line">For information on troubleshooting Jekyll see:</span><br><span class="line"></span><br><span class="line">  https://docs.github.com/articles/troubleshooting-jekyll-builds</span><br><span class="line"></span><br><span class="line">If you have any questions you can submit a request at https://support.github.com/contact?repo_id=367273128&amp;page_build_id=253763232</span><br></pre></td></tr></table></figure>

<p>这是没有安装<code>hexo-deployer-git</code>插件引起的，在本地安装一下即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
</search>
