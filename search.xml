<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Comparator接口是如何定义升序降序的</title>
    <url>/2021/05/27/Comparator%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%8D%87%E5%BA%8F%E9%99%8D%E5%BA%8F%E7%9A%84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用Comparator接口时，总是无法很好的理解到什么是升序降序，每次都需要写个用例跑一次才确定。(；′⌒`)</p>
<h1 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h1><h2 id="升序"><a href="#升序" class="headerlink" title="升序"></a>升序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Arrays.sort(arr, (a, b) -&gt; a - b);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<h2 id="降序"><a href="#降序" class="headerlink" title="降序"></a>降序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Arrays.sort(arr, (a, b) -&gt; b - a);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>

<h1 id="浅谈"><a href="#浅谈" class="headerlink" title="浅谈"></a>浅谈</h1><p>在java.util.Comparator#compare方法上的注释，说得很清楚:</p>
<blockquote>
<p>在比较两个参数的顺序时，第一个参数为a， 第二个参数为b</p>
<ol>
<li>a &lt; b时返回负数</li>
<li>a == b时返回0</li>
<li>a &gt; b时返回正数</li>
<li>建议使用-1、0、1来代表三个返回值</li>
</ol>
</blockquote>
<p>在java.util.Arrays#sort(T[], java.util.Comparator&lt;? super T&gt;)实现中，会根据参数使用不同的排序算法，有binary sort和merge sort。这里直接看merge sort的实现，比较容易理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.util.Arrays#mergeSort(java.lang.Object[], java.lang.Object[], int, int, int, java.util.Comparator)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Object[] src,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Object[] dest,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> off,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Comparator c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = high - low;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Insertion sort on smallest arrays</span></span><br><span class="line">        <span class="keyword">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=low; i&lt;high; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;low &amp;&amp; c.compare(dest[j-<span class="number">1</span>], dest[j])&gt;<span class="number">0</span>; j--)</span><br><span class="line">                    swap(dest, j, j-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recursively sort halves of dest into src</span></span><br><span class="line">        <span class="keyword">int</span> destLow  = low;</span><br><span class="line">        <span class="keyword">int</span> destHigh = high;</span><br><span class="line">        low  += off;</span><br><span class="line">        high += off;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        mergeSort(dest, src, low, mid, -off, c);</span><br><span class="line">        mergeSort(dest, src, mid, high, -off, c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If list is already sorted, just copy from src to dest.  This is an</span></span><br><span class="line">        <span class="comment">// optimization that results in faster sorts for nearly ordered lists.</span></span><br><span class="line">        <span class="keyword">if</span> (c.compare(src[mid-<span class="number">1</span>], src[mid]) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           System.arraycopy(src, low, dest, destLow, length);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merge sorted halves (now in src) into dest</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q &gt;= high || p &lt; mid &amp;&amp; c.compare(src[p], src[q]) &lt;= <span class="number">0</span>)</span><br><span class="line">                dest[i] = src[p++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dest[i] = src[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>关键代码位置就是:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=low; i&lt;high; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;low &amp;&amp; c.compare(dest[j-<span class="number">1</span>], dest[j])&gt;<span class="number">0</span>; j--)</span><br><span class="line">            swap(dest, j, j-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里根据的compare方法的返回值来进行了交换。可以看到当返回值大于0时，则交换dest[j-1] 和dest[j]，而返回值小于等于0时，则顺序保持不变。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在Comparator中，只要compare方法的返回值大于0时，就将数组前一个数和后一个数进行交换，也就是说:</p>
<ol>
<li>如果需要升序，那么只要保证在参数a小于参数b时，返回负数即可</li>
<li>如果需要降序，那么只要保证在参数a小于参数b时，返回正数即可</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker镜像部署spring cloud config repo</title>
    <url>/2021/05/21/%E4%BD%BF%E7%94%A8docker%E9%95%9C%E5%83%8F%E9%83%A8%E7%BD%B2spring-cloud-config-repo/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前折腾了一些spring cloud config repo来存放一些项目的配置文件，由于不需要自定义开发，于是就使用了别人制作好的docker镜像。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h2><p>准备好spring cloud confg repo的配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">git@github.com:&#123;username&#125;/&#123;your-config-repo&#125;.git</span></span><br><span class="line">          <span class="attr">timeout:</span> <span class="number">10</span></span><br><span class="line">          <span class="comment"># 添加你的配置文件路径</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">configs</span></span><br><span class="line">          <span class="attr">clone-on-start:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 支持直接使用用户名和密码登录github仓库，但是不推荐</span></span><br><span class="line">          <span class="comment"># github已经警告过将会不再支持该方式</span></span><br><span class="line">          <span class="comment"># 因此这里建议使用ssh来登录到仓库</span></span><br><span class="line">          <span class="comment">#username: </span></span><br><span class="line">          <span class="comment">#password: </span></span><br></pre></td></tr></table></figure>

<h2 id="配置ssh-key"><a href="#配置ssh-key" class="headerlink" title="配置ssh key"></a>配置ssh key</h2><p>如何生成ssh key以及上传到github，详情见<br>(Connecting to GitHub with SSH)[<a href="https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh]">https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh]</a></p>
<h2 id="使用镜像启动"><a href="#使用镜像启动" class="headerlink" title="使用镜像启动"></a>使用镜像启动</h2><p>镜像: <code>hyness/spring-cloud-config-server:2.2.6.RELEASE-jdk8</code></p>
<p>启动命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 需要将application.yml映射到镜像</span></span><br><span class="line"><span class="comment"># 2. 如果是使用ssh来连接到github，那么需要将当前用户的ssh目录映射到镜像</span></span><br><span class="line"><span class="comment"># 3. 如果应用也是跑到docker中，那么建议创建docker net来进行config server与应用的通信</span></span><br><span class="line"><span class="comment">#    否则需要将config server暴露端口给外部应用访问</span></span><br><span class="line"></span><br><span class="line">docker run --name spring-config-server \</span><br><span class="line"> -v ./application.yml:/config/application.yml \</span><br><span class="line"> -v /home/&#123;usr&#125;/.ssh:/root/.ssh \</span><br><span class="line"> -d hyness/spring-cloud-config-server:2.2.6.RELEASE-jdk8</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>使用fastjson对大型java bean反序列化时，生成的字节码错误: java.lang.VerifyError</title>
    <url>/2021/06/03/%E4%BD%BF%E7%94%A8fastjson%E5%AF%B9%E5%A4%A7%E5%9E%8Bjava-bean%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%EF%BC%8C%E7%94%9F%E6%88%90%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E9%94%99%E8%AF%AF-java-lang-VerifyError/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于业务需求，项目中用于存储数据的bean，定义了很多字段。前面都相安无事，直到前几天新增了某个需求之后，在bean里添加了一个字段后，在从json反序列化时，抛出了<code>java.lang.VerifyError</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.VerifyError: (class: com/alibaba/fastjson/parser/deserializer/FastjsonASMDeserializer_1_LargeJavaBean, method: deserialze signature: (Lcom/alibaba/fastjson/parser/DefaultJSONParser;Ljava/lang/reflect/Type;Ljava/lang/Object;I)Ljava/lang/Object;) Illegal target of jump or branch</span><br><span class="line">	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)</span><br><span class="line">	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3137)</span><br><span class="line">	at java.base/java.lang.Class.getConstructor0(Class.java:3342)</span><br><span class="line">	at java.base/java.lang.Class.getConstructor(Class.java:2151)</span><br><span class="line">	at com.alibaba.fastjson.parser.deserializer.ASMDeserializerFactory.createJavaBeanDeserializer(ASMDeserializerFactory.java:87)</span><br><span class="line">	at com.alibaba.fastjson.parser.ParserConfig.createJavaBeanDeserializer(ParserConfig.java:1082)</span><br><span class="line">	at com.alibaba.fastjson.parser.ParserConfig.getDeserializer(ParserConfig.java:888)</span><br><span class="line">	at com.alibaba.fastjson.parser.ParserConfig.getDeserializer(ParserConfig.java:593)</span><br><span class="line">	at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:699)</span><br><span class="line">	at com.alibaba.fastjson.JSON.parseObject(JSON.java:394)</span><br><span class="line">	at com.alibaba.fastjson.JSON.parseObject(JSON.java:298)</span><br><span class="line">	at com.alibaba.fastjson.JSON.parseObject(JSON.java:588)</span><br><span class="line">	at com.example.Main.main(Main.java:8)</span><br></pre></td></tr></table></figure>

<p>具体的复现demo可以见<a href="https://github.com/alibaba/fastjson/issues/3796">issue 3796</a></p>
<p>在遇到这个bug时，在fastjson的issues中搜索发现，在<a href="https://github.com/alibaba/fastjson/issues/2779">issue 2779</a>中已经遇到该bug，而在早在19年5月就已经修复了该问题。</p>
<p>通过升级fastjosn到目前最新版本（1.2.76），仍然稳定复现该bug，那只能自己先排查一下问题。</p>
<h1 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h1><h2 id="排查业务代码"><a href="#排查业务代码" class="headerlink" title="排查业务代码"></a>排查业务代码</h2><ol>
<li>在对业务代码进行检查后，确定出现问题的bean在实现上是没有问题的。</li>
<li>在注释掉新添加的字段后，进行反序列化时，正常运行</li>
</ol>
<p>于是推测是fastjon的实现问题。</p>
<h2 id="排查错误堆栈信息"><a href="#排查错误堆栈信息" class="headerlink" title="排查错误堆栈信息"></a>排查错误堆栈信息</h2><p>根据错误堆栈，定位到<code>ASMDeserializerFactory</code>的第87行代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.fastjson.parser.deserializer.ASMDeserializerFactory#createJavaBeanDeserializer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] code = cw.toByteArray();</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; deserClass = classLoader.defineClassPublic(classNameFull, code, <span class="number">0</span>, code.length);</span><br><span class="line"><span class="comment">// jvm这里会去动态加载class，而加载class过程中，需要验证class</span></span><br><span class="line">Constructor&lt;?&gt; constructor = deserClass.getConstructor(ParserConfig.class, JavaBeanInfo.class);</span><br></pre></td></tr></table></figure>

<p>jvm在加载class时，需要进行:</p>
<ol>
<li>加载</li>
<li>链接<ol>
<li>验证</li>
<li>准备</li>
<li>解析</li>
</ol>
</li>
<li>初始化</li>
<li>使用</li>
<li>卸载</li>
</ol>
<p>根据<code>java.lang.VerifyError</code>可以知道，在验证阶段出现了错误，那么先把生成的字节码保存到本地。</p>
<h3 id="将字节码保存到本地"><a href="#将字节码保存到本地" class="headerlink" title="将字节码保存到本地"></a>将字节码保存到本地</h3><p>环境:</p>
<ul>
<li>jdk 11.0.9</li>
<li>fastjson 1.2.76</li>
<li>idea 2021</li>
</ul>
<p>操作过程: </p>
<ol>
<li><p>将断点设置在87行</p>
</li>
<li><p>在debug中，使用<code>Evaluate Expression</code>执行</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.write(Paths.get(<span class="string">&quot;./LargeJavaBean.class&quot;</span>), code)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过上面的操作，就拿到生成的class文件。</p>
<h3 id="检查生成的class文件"><a href="#检查生成的class文件" class="headerlink" title="检查生成的class文件"></a>检查生成的class文件</h3><p>直接使用idea打开<code>LargeJavaBean.class</code>，可以发现<code>deserialze()</code>的方法体未能反编译。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.fastjson.parser.deserializer.FastjsonASMDeserializer_1_LargeJavaBean#deserialze</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deserialze</span><span class="params">(DefaultJSONParser param1, Type param2, Object param3, <span class="keyword">int</span> param4)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// $FF: Couldn&#x27;t be decompiled</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回想起<a href="https://github.com/alibaba/fastjson/issues/2779">issue 2779</a>修复的<a href="https://github.com/alibaba/fastjson/pull/2858">pr 2858</a>中提到了可能是由于生成的字节码地址可能为负数。</p>
<blockquote>
<p>blindpirate:<br>在此之前，如果Java bean类过大，ASMDeserializerFactory生成的字节码中<br>的跳转地址如果超过了signed short能表示的范围，生成的字节码中的地址<br>可能是负数，即<br><code>ifeq -32455</code></p>
</blockquote>
<p>那么接下来尝试将class文件编译为jvm指令，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javap -v LargeJavaBean.class &gt; LargeJavaBean.txt</span><br></pre></td></tr></table></figure>

<p>打开<code>LargeJavaBean.txt</code>，使用正则进行全文搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">: .&#123;1,20&#125; *-</span><br></pre></td></tr></table></figure>
<p>发现有一处指令符合该条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">120</span>: if_icmpeq     -<span class="number">32586</span></span><br></pre></td></tr></table></figure>
<p>可以知道<code>if_icmpeq</code>跳转的目的地址溢出，成了负数。因此在jvm在验证该class时抛出了<code>java.lang.VerifyError</code></p>
<h2 id="尝试修复bug"><a href="#尝试修复bug" class="headerlink" title="尝试修复bug"></a>尝试修复bug</h2><p>根据<a href="https://github.com/alibaba/fastjson/pull/2858">pr 2858</a>提到的方向，找到了在b站上一个解决该问题的视频<a href="https://www.bilibili.com/video/BV1JJ41197UK?share_source=copy_web">现场直播给阿里巴巴Fastjson修bug</a>。</p>
<p>整体思路就是通过将对应的跳转语句转换为相反的跳转语句 + goto_w来实现。<br>例如:<code>ifeq</code>和<code>ifne + goto_w</code>在逻辑上是等价的。</p>
<p>同时<code>goto_w</code>使用4个字节来保存跳转的目的地址，因此可以避免出现溢出的问题。</p>
<h3 id="定位写入错误指令的代码位置"><a href="#定位写入错误指令的代码位置" class="headerlink" title="定位写入错误指令的代码位置"></a>定位写入错误指令的代码位置</h3><p>根据错误指令的上下文来看，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">107</span>: invokevirtual #<span class="number">827</span>                <span class="comment">// Method com/alibaba/fastjson/parser/DefaultJSONParser.setContext:(Lcom/alibaba/fastjson/parser/ParseContext;Ljava/lang/Object;Ljava/lang/Object;)Lcom/alibaba/fastjson/parser/ParseContext;</span></span><br><span class="line"><span class="number">110</span>: astore        <span class="number">10</span></span><br><span class="line"><span class="number">112</span>: aload         <span class="number">5</span></span><br><span class="line"><span class="number">114</span>: getfield      #<span class="number">831</span>                <span class="comment">// Field com/alibaba/fastjson/parser/JSONLexerBase.matchStat:I</span></span><br><span class="line"><span class="number">117</span>: ldc_w         #<span class="number">832</span>                <span class="comment">// int 4</span></span><br><span class="line"><span class="number">120</span>: if_icmpeq     -<span class="number">32586</span></span><br><span class="line"><span class="number">123</span>: iconst_0</span><br><span class="line"><span class="number">124</span>: istore        <span class="number">11</span></span><br><span class="line"><span class="number">126</span>: iconst_0</span><br><span class="line"><span class="number">127</span>: istore        <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>在写入<code>if_icmpeq</code>前会先写入<code>ldc_w</code>、<code>getfield</code>以及<code>invokevirtual</code>，通过这些关键字，定位到了<code>ASMDeserializerFactory</code>的702行代码: <code>mw.visitJumpInsn(IF_ICMPEQ, return_);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.fastjson.parser.deserializer.ASMDeserializerFactory#_deserialzeArrayMapping</span></span><br><span class="line"><span class="comment">// 684行 - 705行</span></span><br><span class="line">&#123;</span><br><span class="line">    mw.visitVarInsn(ALOAD, <span class="number">1</span>); <span class="comment">// parser</span></span><br><span class="line">    mw.visitMethodInsn(INVOKEVIRTUAL, DefaultJSONParser, <span class="string">&quot;getContext&quot;</span>, <span class="string">&quot;()&quot;</span> + desc(ParseContext.class));</span><br><span class="line">    mw.visitVarInsn(ASTORE, context.<span class="keyword">var</span>(<span class="string">&quot;context&quot;</span>));</span><br><span class="line"></span><br><span class="line">    mw.visitVarInsn(ALOAD, <span class="number">1</span>); <span class="comment">// parser</span></span><br><span class="line">    mw.visitVarInsn(ALOAD, context.<span class="keyword">var</span>(<span class="string">&quot;context&quot;</span>));</span><br><span class="line">    mw.visitVarInsn(ALOAD, context.<span class="keyword">var</span>(<span class="string">&quot;instance&quot;</span>));</span><br><span class="line">    mw.visitVarInsn(ALOAD, <span class="number">3</span>); <span class="comment">// fieldName</span></span><br><span class="line">    mw.visitMethodInsn(INVOKEVIRTUAL, DefaultJSONParser, <span class="string">&quot;setContext&quot;</span>, <span class="comment">//</span></span><br><span class="line">                        <span class="string">&quot;(&quot;</span> + desc(ParseContext.class) + <span class="string">&quot;Ljava/lang/Object;Ljava/lang/Object;)&quot;</span></span><br><span class="line">                                                                        + desc(ParseContext.class));</span><br><span class="line">    mw.visitVarInsn(ASTORE, context.<span class="keyword">var</span>(<span class="string">&quot;childContext&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mw.visitVarInsn(ALOAD, context.<span class="keyword">var</span>(<span class="string">&quot;lexer&quot;</span>));</span><br><span class="line">mw.visitFieldInsn(GETFIELD, JSONLexerBase, <span class="string">&quot;matchStat&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">mw.visitLdcInsn(com.alibaba.fastjson.parser.JSONLexerBase.END);</span><br><span class="line"><span class="comment">// 这里的跳转地址溢出了</span></span><br><span class="line">mw.visitJumpInsn(IF_ICMPEQ, return_);</span><br><span class="line"></span><br><span class="line">mw.visitInsn(ICONST_0); <span class="comment">// UNKOWN</span></span><br><span class="line">mw.visitIntInsn(ISTORE, context.<span class="keyword">var</span>(<span class="string">&quot;matchStat&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="试着修复bug"><a href="#试着修复bug" class="headerlink" title="试着修复bug"></a>试着修复bug</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- mw.visitJumpInsn(IF_ICMPEQ, return_);</span></span><br><span class="line"><span class="addition">+ Label continue_3 = new Label();</span></span><br><span class="line"><span class="addition">+ mw.visitJumpInsn(IF_ICMPNE, continue_3);</span></span><br><span class="line"><span class="addition">+ mw.visitJumpInsn(GOTO_W, return_);</span></span><br><span class="line"><span class="addition">+ mw.visitLabel(continue_3);</span></span><br></pre></td></tr></table></figure>

<p>思路就是使用<code>if_icmpne + goto_w</code>替换掉<code>if_icmpeq</code>来规避跳转的目的地址溢出的问题。</p>
<h1 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h1><p>在跟同事讨论构造稳定复现该bug的用例时，发现不仅仅是之前提到的跳转有问题，而是在多处跳转都有可能会溢出。新的bug见<a href="https://github.com/alibaba/fastjson/issues/3794">issue 3794</a>，该issue提供了一个新的测试用例，发现只要字段是96个时就会出现<code>java.lang.VerifyError</code>，同时生成的字节码目的地址为负数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">if_icmpne -17541</span><br></pre></td></tr></table></figure>
<p>由于出现该错误的地方很多，也没时间再去一步步定位问题，目前在考虑项目中使用gson来代替fastjon。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>fastjosn的这个bug的源头还是来自于底层使用的asm库版本过低导致的，新版本的asm库修复了很多由于跳转地址溢出的问题。希望fastjson能够把asm库的新版本代码合进去。</li>
<li>项目中使用的bean不会太大时，使用fastjson是通常没有问题的，如果出现了该问题，又仍然得继续用fastjson时，可以考虑使用<code>fieldBase = true</code>来避免使用asm来生成字节码。具体的使用方式见<a href="https://github.com/alibaba/fastjson/wiki/FieldBased_cn">FieldBased_cn</a>。</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>使用thumbnailator进行图片缩放</title>
    <url>/2021/06/08/%E4%BD%BF%E7%94%A8thumbnailator%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在之前基于<a href="https://github.com/mamoe/mirai">mirai</a>实现qq机器人时，有个根据关键字来回复图片的需求。开始的时候是直接将原图发送出去，但是由于上传网速和原图的大小的限制，导致图片发送过于缓慢。不过想了想，对图片的精度要求并不高，那么可以选择压缩图片，尝试过几个开源库之后，选择了<a href="https://github.com/coobird/thumbnailator">thumbnailator</a>来进行图片的压缩。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>导入依赖: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/net.coobird/thumbnailator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.coobird<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thumbnailator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>目前最新版本号位<code>0.4.14</code>，自行选择相应的版本号<a href="https://mvnrepository.com/artifact/net.coobird/thumbnailator">Thumbnailator maven仓库</a>。</p>
<h2 id="从图像文件来创建缩略图"><a href="#从图像文件来创建缩略图" class="headerlink" title="从图像文件来创建缩略图"></a>从图像文件来创建缩略图</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thumbnails.of(<span class="keyword">new</span> File(<span class="string">&quot;original.jpg&quot;</span>))   <span class="comment">// 图片来源</span></span><br><span class="line">        .size(<span class="number">160</span>, <span class="number">160</span>)</span><br><span class="line">        .toFile(<span class="keyword">new</span> File(<span class="string">&quot;thumbnail.jpg&quot;</span>)); <span class="comment">// 输出图片路径</span></span><br></pre></td></tr></table></figure>

<p>同时<code>Thumbnails.of()</code>也支持传入字符串路径的来读取图片。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thumbnails.of(<span class="string">&quot;original.jpg&quot;</span>)</span><br><span class="line">        .size(<span class="number">160</span>, <span class="number">160</span>)</span><br><span class="line">        .toFile(<span class="string">&quot;thumbnail.jpg&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="创建旋转和水印的缩略图"><a href="#创建旋转和水印的缩略图" class="headerlink" title="创建旋转和水印的缩略图"></a>创建旋转和水印的缩略图</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thumbnails.of(<span class="keyword">new</span> File(<span class="string">&quot;original.jpg&quot;</span>))       <span class="comment">// 图片来源</span></span><br><span class="line">        .size(<span class="number">160</span>, <span class="number">160</span>)</span><br><span class="line">        .rotate(<span class="number">90</span>)            <span class="comment">// 顺时针旋转90°</span></span><br><span class="line">        .watermark(Positions.BOTTOM_RIGHT, ImageIO.read(<span class="keyword">new</span> File(<span class="string">&quot;watermark.png&quot;</span>)), <span class="number">0.5f</span>)   <span class="comment">// 添加水印</span></span><br><span class="line">        .outputQuality(<span class="number">0.8</span>)     <span class="comment">// 输出的质量，可以用于压缩图片</span></span><br><span class="line">        .toFile(<span class="keyword">new</span> File(<span class="string">&quot;image-with-watermark.jpg&quot;</span>)); <span class="comment">// 输出图片路径</span></span><br></pre></td></tr></table></figure>

<h2 id="将创建的缩略图写入到OutputStream"><a href="#将创建的缩略图写入到OutputStream" class="headerlink" title="将创建的缩略图写入到OutputStream"></a>将创建的缩略图写入到<code>OutputStream</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream os = ...;</span><br><span class="line">		</span><br><span class="line">Thumbnails.of(<span class="string">&quot;large-picture.jpg&quot;</span>)</span><br><span class="line">        .size(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        .outputFormat(<span class="string">&quot;png&quot;</span>)   <span class="comment">// 输出格式</span></span><br><span class="line">        .toOutputStream(os);   <span class="comment">// 写入的输出流</span></span><br></pre></td></tr></table></figure>

<h2 id="创建固定大小的缩略图"><a href="#创建固定大小的缩略图" class="headerlink" title="创建固定大小的缩略图"></a>创建固定大小的缩略图</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedImage originalImage = ImageIO.read(<span class="keyword">new</span> File(<span class="string">&quot;original.png&quot;</span>));</span><br><span class="line"></span><br><span class="line">BufferedImage thumbnail = Thumbnails.of(originalImage)</span><br><span class="line">        .size(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        .asBufferedImage();</span><br></pre></td></tr></table></figure>

<h2 id="设置图片的输出规模"><a href="#设置图片的输出规模" class="headerlink" title="设置图片的输出规模"></a>设置图片的输出规模</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedImage originalImage = ImageIO.read(<span class="keyword">new</span> File(<span class="string">&quot;original.png&quot;</span>));</span><br><span class="line"></span><br><span class="line">BufferedImage thumbnail = Thumbnails.of(originalImage)</span><br><span class="line">        .scale(<span class="number">0.25</span>)   <span class="comment">// 缩放为25%</span></span><br><span class="line">        .asBufferedImage();</span><br></pre></td></tr></table></figure>

<h2 id="旋转图片"><a href="#旋转图片" class="headerlink" title="旋转图片"></a>旋转图片</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedImage originalImage = ImageIO.read(<span class="keyword">new</span> File(<span class="string">&quot;original.jpg&quot;</span>));</span><br><span class="line"></span><br><span class="line">BufferedImage thumbnail = Thumbnails.of(originalImage)</span><br><span class="line">        .size(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        .rotate(<span class="number">90</span>)    <span class="comment">// 顺时针旋转90°</span></span><br><span class="line">        .asBufferedImage();</span><br></pre></td></tr></table></figure>

<h2 id="为图片增加水印"><a href="#为图片增加水印" class="headerlink" title="为图片增加水印"></a>为图片增加水印</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedImage originalImage = ImageIO.read(<span class="keyword">new</span> File(<span class="string">&quot;original.jpg&quot;</span>));    <span class="comment">// 原始图片</span></span><br><span class="line">BufferedImage watermarkImage = ImageIO.read(<span class="keyword">new</span> File(<span class="string">&quot;watermark.png&quot;</span>));  <span class="comment">// 用做水印的图片</span></span><br><span class="line"></span><br><span class="line">BufferedImage thumbnail = Thumbnails.of(originalImage)</span><br><span class="line">        .size(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        .watermark(Positions.BOTTOM_RIGHT, watermarkImage, <span class="number">0.5f</span>)  <span class="comment">// 设置水印</span></span><br><span class="line">        .asBufferedImage();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>根据<code>watermark()</code>的第一个参数<code>Positions</code>这个枚举来设置水印的位置</li>
<li>根据<code>watermark()</code>的最后一个参数来调整水印的透明度，<code>0.0f</code>是完全透明的，<code>1.0f</code>是完全不透明</li>
</ul>
<h2 id="将多张缩略图写入到指定目录"><a href="#将多张缩略图写入到指定目录" class="headerlink" title="将多张缩略图写入到指定目录"></a>将多张缩略图写入到指定目录</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File destinationDir = <span class="keyword">new</span> File(<span class="string">&quot;path/to/output&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thumbnails.of(<span class="string">&quot;apple.jpg&quot;</span>, <span class="string">&quot;banana.jpg&quot;</span>, <span class="string">&quot;cherry.jpg&quot;</span>)</span><br><span class="line">        .size(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        .toFiles(destinationDir, Rename.PREFIX_DOT_THUMBNAIL);</span><br></pre></td></tr></table></figure>
<p>在写入到指定目录时，可以设置是否在文件名上增加前缀。设置了<code>Rename.PREFIX_DOT_THUMBNAIL</code>以后，输出的文件如下:</p>
<ul>
<li>path/to/output/thumbnail.apple.jpg</li>
<li>path/to/output/thumbnail.banana.jpg</li>
<li>path/to/output/thumbnail.cherry.jpg</li>
</ul>
<p>如果设置为<code>Rename.NO_CHANGE</code>，那么不会修改输出时的文件名。</p>
<h2 id="使用byte数组来进行图片的压缩"><a href="#使用byte数组来进行图片的压缩" class="headerlink" title="使用byte数组来进行图片的压缩"></a>使用byte数组来进行图片的压缩</h2><p>由于在获取图片是来自于byte数组，同时需要输出为byte数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] compressImage(<span class="keyword">byte</span>[] bytes) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream(<span class="number">1024</span>);</span><br><span class="line">            ByteArrayInputStream inputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes)) &#123;</span><br><span class="line">        Thumbnails.of(inputStream)</span><br><span class="line">                .scale(<span class="number">1.0f</span>)</span><br><span class="line">                .outputQuality(<span class="number">0.3f</span>)</span><br><span class="line">                .outputFormat(<span class="string">&quot;jpg&quot;</span>)</span><br><span class="line">                .toOutputStream(outputStream);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> outputStream.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然只是在写玩具的时候接触到需要进行图片压缩的场景，但是也可以借此拓宽自己的视野。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/coobird/thumbnailator">coobird / thumbnailator</a></li>
<li><a href="https://github.com/coobird/thumbnailator/wiki/Examples#examples">thumbnailator examples</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>thumbnailator</tag>
      </tags>
  </entry>
  <entry>
    <title>关于折腾github pages那些事</title>
    <url>/2021/05/17/%E5%85%B3%E4%BA%8E%E6%8A%98%E8%85%BEgithub-pages%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前用过CSDN来写博客，但由于CSDN越来越拉，不得已就自建博客了。由于之前阿里云到期，现在在折腾腾讯云，自建博客也凉凉。于是就干脆折腾下github pages。</p>
<p>以下是在折腾过程中参考的文章，以及遇到的问题。</p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>以下大部分内容参考的是微信文章<a href="https://mp.weixin.qq.com/s/3li0n8REcU1DviwWiEYw_A">超全面！如何用 GitHub 从零开始搭建一个博客 ？</a>。</p>
<p>这里也不做复制怪了，有兴趣的之前看别人的文章即可。</p>
<p>关于使用github workflow进行自动构建，可以参考官方教程<a href="https://hexo.io/docs/github-pages">GitHub Pages</a>。</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="github-pages的域名问题"><a href="#github-pages的域名问题" class="headerlink" title="github pages的域名问题"></a>github pages的域名问题</h2><p>github pages的域名通常是<code>&#123;username&#125;.github.io</code>，这个前提是基于这个仓库与你的自己账号名相同（不是指登录账号），否则域名将会是<code>&#123;username&#125;.github.io/&#123;reponame&#125;</code>。</p>
<p>同时hexo的模板代码生成的根路径是直接使用的<code>/</code>，所以在有reponame时，访问hexo生成的页面时会加载不到css、js。所以将自己的账号名更改以后，正常的可以用<code>&#123;username&#125;.github.io</code>进行访问。</p>
<h2 id="使用github-workflow构建失败"><a href="#使用github-workflow构建失败" class="headerlink" title="使用github workflow构建失败"></a>使用github workflow构建失败</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The page build failed <span class="keyword">for</span> the `main` branch with the following error:</span><br><span class="line"></span><br><span class="line">The tag `note` on line 11 <span class="keyword">in</span> `themes/next/docs/AUTHORS.md` is not a recognized Liquid tag. For more information, see https://docs.github.com/github/working-with-github-pages/troubleshooting-jekyll-build-errors-for-github-pages-sites<span class="comment">#unknown-tag-error.</span></span><br><span class="line"></span><br><span class="line">For information on troubleshooting Jekyll see:</span><br><span class="line"></span><br><span class="line">  https://docs.github.com/articles/troubleshooting-jekyll-builds</span><br><span class="line"></span><br><span class="line">If you have any questions you can submit a request at https://support.github.com/contact?repo_id=367273128&amp;page_build_id=253761474</span><br></pre></td></tr></table></figure>

<p>在参考了issue<a href="https://github.com/theme-next/hexo-theme-next/issues/410">The tag note is not a recognized Liquid tag</a>，我选择直接删除掉next主题下的doc目录，目前暂不知道是否会有版权问题，如果会造成侵权，那么我再还原回去（逃。</p>
<h2 id="使用github-workflow构建成功却有警告"><a href="#使用github-workflow构建成功却有警告" class="headerlink" title="使用github workflow构建成功却有警告"></a>使用github workflow构建成功却有警告</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The page build completed successfully, but returned the following warning <span class="keyword">for</span> the `main` branch:</span><br><span class="line"></span><br><span class="line">You are attempting to use a Jekyll theme, <span class="string">&quot;next&quot;</span>, <span class="built_in">which</span> is not supported by GitHub Pages. Please visit https://pages.github.com/themes/ <span class="keyword">for</span> a list of supported themes. If you are using the <span class="string">&quot;theme&quot;</span> configuration variable <span class="keyword">for</span> something other than a Jekyll theme, we recommend you rename this variable throughout your site. For more information, see https://docs.github.com/github/working-with-github-pages/adding-a-theme-to-your-github-pages-site-using-jekyll.</span><br><span class="line"></span><br><span class="line">For information on troubleshooting Jekyll see:</span><br><span class="line"></span><br><span class="line">  https://docs.github.com/articles/troubleshooting-jekyll-builds</span><br><span class="line"></span><br><span class="line">If you have any questions you can submit a request at https://support.github.com/contact?repo_id=367273128&amp;page_build_id=253763232</span><br></pre></td></tr></table></figure>

<p>这是没有安装<code>hexo-deployer-git</code>插件引起的，在本地安装一下即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
</search>
